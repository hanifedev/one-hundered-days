# Day 68: Unit Testing - Mocking Dependencies

## ğŸ“ Today's Tasks

1.  **Understand Mocking:** Learn what mocking is and why it's necessary for unit testing (isolating code under test).
2.  **Install Mockito:** Add the `mockito` package and `build_runner` for generating mock classes.
3.  **Create Mock Classes:** Generate mock classes for dependencies (e.g., API clients, database, repositories).
4.  **Use Mocks in Tests:** Write tests that use mocks to simulate dependencies and control their behavior.
5.  **Verify Mock Calls:** Use `verify()` to ensure that mocked dependencies were called correctly with expected parameters.

## ğŸ“– Task Explanations

Today, you'll learn about mocking, which is essential for unit testing code that has dependencies. When testing a function that calls an API or database, you don't want to actually make those calls in your tests (they're slow, unreliable, and require setup). Instead, you create "mocks" that simulate those dependencies.

Mocking allows you to:
- **Isolate code:** Test only the code you're interested in, not its dependencies
- **Control behavior:** Make dependencies return specific values or throw errors
- **Speed up tests:** Avoid slow network calls or database operations
- **Test edge cases:** Simulate error conditions that are hard to reproduce

You'll use `mockito`, which is the standard mocking package for Dart/Flutter. It uses code generation to create mock classes. You annotate your dependencies with `@GenerateMocks()`, run `build_runner`, and mockito generates mock classes for you.

In your tests, you'll create instances of these mocks, configure their behavior using `when()`, and verify they were called correctly using `verify()`.

## ğŸ’¡ What You'll Gain

By the end of today, you will understand mocking and how to use it in your unit tests. You'll be able to isolate code under test, control dependency behavior, and verify interactions. This skill is crucial for testing code with external dependencies.

## ğŸ“š Dictionary for Developers

*   **Mocking:** Creating fake objects that simulate the behavior of real dependencies, allowing you to test code in isolation.
*   **Mock:** A fake object that mimics the interface of a real object but allows you to control its behavior in tests.
*   **`mockito` Package:** A Dart package for creating mock objects, using code generation to create mock classes.
*   **`when()`:** A function used to configure mock behavior, specifying what a mock method should return when called.
*   **`verify()`:** A function used to verify that a mock method was called with specific parameters, ensuring correct interactions.
